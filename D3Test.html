<!DOCTYPE html>
<html>
  <body>
    <script src="http://d3js.org/d3.v2.min.js" charset="utf-8"></script>

<p height="1">
<svg id="chart" width="300px" height="400px">
  <title>Golden Watch</title>
  <circle cx="150" cy="150" r="140" fill="ghostwhite" stroke="goldenrod" stroke-width="2" />
  <circle cx="150" cy="150" r="130" fill="none" stroke="goldenrod" stroke-width="3" stroke-dasharray="2,11.613568" transform="rotate(-.12)" />
  <line y2="-130" stroke="gold" stroke-width="1" transform="translate(150,150) rotate(0)">
    <animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="60s" by="360" />
  </line>
  <line y2="-120" stroke="gold" stroke-width="2" transform="translate(150,150) rotate(0)">
    <animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="60min" by="360" />
  </line>
  <line y2="-110" stroke="gold" stroke-width="3" transform="translate(150,150) rotate(0)">
    <animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="12h" by="360" />
  </line>
</svg>
</p>

<script type="text/javascript">
"use strict";
var cellwidth = 25, cellheight = 25, rows = 12, cols = 24
var width = cellwidth*cols,
    height = cellheight*rows;

var svg = d3.select("#chart")
	    .attr("width", width)
	    .attr("height", height);
var g = svg.append("g");

//var square = g.selectAll("rect").data([{"x":75,"y":50}]).enter().append("rect")
//      .attr("x",function(d) {return d.x;})
//      .attr("y",function(d) {return d.y;})
//      .attr("width",50)
//      .attr("height",50)
//      .style("fill","red");

var dat = [{"x":20,"y":20},{"x":80,"y":160},{"x":120,"y":160},{"x":180,"y":20}];

//var path = g.append("path").attr("d","M 20,20 L "+ dat.map(function(d) {return [d.x,d.y].join(",");}).join(" "))
//                .style("fill","none")
//                .style("stroke","blue")
//                .style("stroke-width",4);
//path.append("animate").attr("attributeName","stroke").attr("to","green").attr("dur","10s").attr("repeatCount","indefinite");
//
//var path2 = g.append("path").attr("d","M 20,40 L "+ dat.map(function(d) {return [d.x,d.y+20].join(",");}).join(" "))
//	                .style("fill","none")
//	                .style("stroke","blue")
//	                .style("stroke-width",4);
//path2.transition().duration(10000).style("stroke","green");

var animate = function (selection,attr,to,dur,repcnt) {
  return selection.append("animate").attr("attributeName",attr).attr("to",to).attr("dur",(dur/1000)+"s").attr("repeatCount",repcnt);
};

//var path3 = g.append("path").attr("d","M 20,60 L "+ dat.map(function(d) {return [d.x,d.y+40].join(",");}).join(" "))
//	                .style("fill","none")
//	                .style("stroke","blue")
//	                .style("stroke-width",4)
//                      .style("stroke-dasharray","0,0,15,15")
//                      .style("stroke-dashoffset",0);
//path3.call(animate,"stroke-dasharray","15,15,0,0",1000,"indefinite");
//path3.call(animate,"stroke-dashoffset",-30,1000,"indefinite");

// .. // .. // Begin

var keys = [];
for(var i=0; i < 222; i++) {
  keys[i] = 0;
}

var sh = 83,
    buffer = 30,
    pi = 3.14159265,
    canMove = 1,
    canShoot = 1;

// Add bits
var bits = [{"id":"bit1","file":"Sounds/chord.wav"},{"id":"bit2","file":"Sounds/chord.wav"}], sndbits= new Object();
for(var i=0; i < bits.length; i++) {
  sndbits[bits[i].id] = document.createElement("AUDIO")
  sndbits[bits[i].id].setAttribute("src",bits[i].file);
}
var aud = svg.selectAll("audio").data(bits).enter().append("audio")
             .attr("id",function(d) {return d.id})
             .attr("src",function(d) {return d.file}).attr("preload","auto");

d3.select("body").on("keydown", function() {
                                  var ev = d3.event.keyCode;
                                  if(keys[ev]==0)
                                    keyPress(ev);
                                  keys[ev] = 1;
                                })
                 .on("keyup",   function() {
                                  var ev = d3.event.keyCode;
                                  if(keys[ev]==1)
                                    keyRelease(ev);
                                  keys[ev] = 0;
                                });

function keyPress(keyCode) {
  //g.selectAll("polygon").style("fill","red");
  if(keyCode==sh & canShoot) {
    // Press S
    for (var i=0; i < 10; i++)
    new Project(g,pl.pos.x+10+i,pl.pos.y,[0,20,20,0],[2,2,-2,-2],pl.direction,3.);
  }
  if(keyCode==84) {
    // Press T
    tmp.remove(thg1)
    console.log(tmp);
  }
  if(keyCode==80) {
    // Press P
    //sndbits.bit1.play();
    console.log(pl.cell)
  }
}

function keyRelease(keyCode) {
  
}

// All Class definitions


class ThingList {
  constructor(data) {
    this.start = null;
    this.end   = null;
  }
  
  makeNode () {
    return {thing:null,next:null};
  }
  
  add (thing) {
    if(this.start===null) {
      this.start = this.makeNode();
      this.end = this.start;
    }
    else {
      this.end.next = this.makeNode();
      this.end = this.end.next;
    }
    //console.log(this.end.next===this.start.next)
    //console.log(this.start.next);
    this.end.thing = thing;
  }
  
  remove (thing) {
    var current = this.start;
    if (current.thing === thing) {
      this.start = current.next;
      if(current===this.end) {
        this.end = null;
      }
      return(1);
    }
    while (current.next !== null) {
      if(current.next.thing === thing) {
        current.next = current.next.next;
        if(current.next===this.end) {
          this.end = current;
        }
        return(1);
      }
      current = current.next
    }
    return(0);
  }
}

class Cell {
  constructor() {
    this.ThingList = new ThingList()
    this.nl = null;
    this.nu = null;
    this.nr = null;
    this.nd = null;
    this.nul = null;
    this.nur = null;
    this.ndl = null;
    this.ndr = null;
  }
  
  movein(thing) {
    this.ThingList.add(thing)
  }
  
  moveout(thing) {
    this.ThingList.remove(thing)
  }
}

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  
  static distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    
    return Math.sqrt(dx*dx + dy*dy);
  }
  
  add (arr) {
    return {"x":this.x+arr.x,"y":this.y+arr.y}
  }
  
  shift (arr) {
    this.x = this.x + arr.x;
    this.y = this.y + arr.y;
  }
}

var Things = [];

class Thing {
  constructor(parent,x,y,xs,ys) {
    this.pos = new Point(x,y);
    this.poly = [];
    this.string = "";
    for(var i =0; i < xs.length; i++) {
      this.poly.push(new Point(xs[i],ys[i]));
      this.string = this.string + " " + (xs[i]) + "," + (ys[i]);
    }
    this.x1 = xs.sort(function(a,b){return a-b})[0];
    this.x2 = xs.sort(function(a,b){return b-a})[0];
    this.y1 = ys.sort(function(a,b){return a-b})[0];
    this.y2 = ys.sort(function(a,b){return b-1})[0];
    this.obj = parent.append("polygon").attr("points",this.string).attr("transform","translate("+this.pos.x+","+this.pos.y+")")
                     .style("fill","#EEEEEE");
    this.class = "Thing";
    this.cell = Cells[Math.floor(x/cellwidth)][Math.floor(y/cellheight)];
    this.cell.movein(this);
    Things.push(this);
  }
  
  checkCell () {
    var tmp = Cells[Math.floor(this.pos.x/cellwidth)][Math.floor(this.pos.y/cellheight)]
    console.log(tmp);
    if(this.cell !== tmp) {
      if(tmp === undefined)
        return this.remove();
      this.cell.moveout(this);
      this.cell = tmp;
      this.cell.movein(this);
    }
  }
  
  trymove(x,y,relative) {
    if(relative===undefined)
      relative = 1;
    var curr = this,
        oldx=this.pos.x,
        oldy=this.pos.y;
    this.move(x,y,relative,1);
    var coll = this.isCollisionAny();
    if(coll) {
      this.move(oldx,oldy,0);
    }
    else
      this.move(0,0,1,0);
    return !coll;
  }
  
  move(x,y,relative,tentative) {
    if(relative===undefined)
      relative = 1;
    if(tentative===undefined)
      tentative = 0;
    
    this.pos.x = this.pos.x*relative + x;
    this.pos.y = this.pos.y*relative + y;
    this.obj.attr("transform","translate("+this.pos.x+","+this.pos.y+")");
    
    if(!tentative) {
      this.checkCell();
      if (this.isCollisionAny() & false)
        this.remove();
    }
  }
  
  isPointInPoly(pt) {
      pt.x = pt.x - this.pos.x;
      pt.y = pt.y - this.pos.y;
      for(var c = false, d = false, i = -1, l = this.poly.length, j = l - 1; ++i < l; j = i) {
          ((this.poly[i].y <= pt.y && pt.y <= this.poly[j].y) || (this.poly[j].y <= pt.y && pt.y <= this.poly[i].y))
          && (pt.x <  (this.poly[j].x - this.poly[i].x) * (pt.y - this.poly[i].y) / (this.poly[j].y - this.poly[i].y) + this.poly[i].x)
          && (c = !c) ;
          ((this.poly[i].y <= pt.y && pt.y <= this.poly[j].y) || (this.poly[j].y <= pt.y && pt.y <= this.poly[i].y))
          && (pt.x <=(this.poly[j].x - this.poly[i].x) * (pt.y - this.poly[i].y) / (this.poly[j].y - this.poly[i].y) + this.poly[i].x)
          && (d = !d) 
          //if (pt.x == (this.poly[j].x - this.poly[i].x) * (pt.y - this.poly[i].y) / (this.poly[j].y - this.poly[i].y) + this.poly[i].x) {
          //if (pt.x == (this.poly[j].x - this.poly[i].x) * (pt.y - this.poly[i].y) / (this.poly[j].y - this.poly[i].y) + this.poly[i].x) {
          //  c = true;
          //  break;
          //}
      }
      return (c||d);
  }
  
  static isCollisionBox(thing1,thing2) {
    return !(thing1===thing2 || thing1.y2+thing1.pos.y < thing2.y1+thing2.pos.y || thing1.y1+thing1.pos.y > thing2.y2+thing2.pos.y || 
             thing1.x2+thing1.pos.x < thing2.x1+thing2.pos.x || thing1.x1+thing1.pos.x > thing2.x2+thing2.pos.x);
  }
  
  static isCollision(thing1,thing2) {
    var inbox = Thing.isCollisionBox(thing1,thing2);
    if (inbox) {
      for(var i=0; i < thing1.poly.length; i++) {
        if(thing2.isPointInPoly(thing1.poly[i].add(thing1.pos)) )
          return 1;
      }
      for(var i=0; i < thing2.poly.length; i++) {
        if(thing1.isPointInPoly(thing2.poly[i].add(thing2.pos)) )
          return 1;
      }
      return 0;
    }
    else
      return 0;
  }
  
  isCollisionAny() {
    var oldx=this.pos.x,
        oldy=this.pos.y;
    for(var cl = 0; cl<9; cl++) {
      var curcell;
      switch (cl) {
        case 0:
          curcell = this.cell;
          break;
        case 1:
          curcell = this.cell.nul;
          break;
        case 2:
          curcell = this.cell.nu;
          break;
        case 3:
          curcell = this.cell.nur;
          break;
        case 4:
          curcell = this.cell.nr;
          break;
        case 5:
          curcell = this.cell.ndr;
          break;
        case 6:
          curcell = this.cell.nd;
          break;
        case 7:
          curcell = this.cell.ndl;
          break;
        case 8:
          curcell = this.cell.nl;
          break;
      }
      if(curcell !== null) {
        var poss = curcell.ThingList
        var node = poss.start
        while(node !== null) {
          if(Thing.isCollision(this,node.thing)) {
            return 1;
          }
          node = node.next;
        }
      }
    }
    //for(var i=0; i < Things.length; i++) {
    //    if(Thing.isCollision(curr,Things[i])) {
    //      return 1;
    //    }
    //}
    return 0;
  }
  
  onStep () {
    this.obj.attr("points",this.string).attr("transform","translate("+this.pos.x+","+this.pos.y+")");
    if (this.pos.x < 0 - buffer || this.pos.x > width + buffer || this.pos.y < 0 - buffer || this.pos.y > height + buffer) {
      this.remove()
    }
  }
  
  remove() {
    this.obj.remove();
    Things.splice(Things.indexOf(this),1);
  }
}

class Main extends Thing {
  constructor(parent,x,y,xs,ys,direction) {
    super(parent,x,y,xs,ys);
    if(direction===undefined)
      this.direction = 90;
    else
      this.direction = direction;
    this.class = "Main";
    this.image = g.append("image").attr("x",this.x1).attr("y",this.y1).attr("width",this.x2-this.x1).attr("height",this.y2-this.y1)
                     //.attr("xlink:href","globe.jpg").attr("transform","translate("+this.pos.x+","+this.pos.y+")");
    //<image x="0" y="0" width="236" height="200" xlink:href="globe.jpg" />
  }
  
  onStep () {
    this.obj.attr("points",this.string).attr("transform","translate("+this.pos.x+","+this.pos.y+") rotate("+this.direction+")");
    
  }
  
  remove() {
    super.remove();
    canMove = 0;
    canShoot = 0;
    pl = 0;
  }
}

class Project extends Thing {
  constructor(parent,x,y,xs,ys,direc,veloc) {
    super(parent,x,y,xs,ys);
    this.direc = direc;
    this.veloc = veloc;
  }
  
  onStep() {
    super.onStep();
    this.move(Math.cos(this.direc*pi/180)*this.veloc,Math.sin(this.direc*pi/180)*this.veloc,1,0);
  }
}

var Menys = [];
class Meny extends Thing {
  constructor(parent,x,y,xs,ys) {
    super(parent,x,y,xs,ys);
    Menys.push(this);
    this.class = "Meny"
    this.obj.style("fill","red")
  }
  
  remove() {
    super.remove();
    Menys.splice(Menys.indexOf(this),1)
  }
}

class Clock {
  constructor(parent,time,x,y,rad) {
    this.time = time;
    this.pos = new Point(x,y);
    this.rad = rad;
    this.obj = parent.append("circle").attr("cx",0).attr("cy",0).attr("r",rad).data(hands).enter().append("rect").
    this.obj.attr("transform","translate("+x+","+y+")")
  }
  
  onStep() {
    this.time = this.time + 1;
    this.obj.attr("transform","translate("+this.pos.x+","+this.pos.y+")")
  }
}

var Cells = new Array(rows);
for (var i=0; i<rows; i++) {
  Cells[i] = new Array(cols);
  for (var j=0; j<cols; j++) {
    Cells[i][j] = new Cell();
  }
}
console.log(Cells);
for (var i=0; i<rows; i++) {
  for (var j=0; j<cols; j++) {
    Cells[i][j].nl = (i>0) ? Cells[i-1][j]: null;
    Cells[i][j].nu = (j>0) ? Cells[i][j-1]: null;
    Cells[i][j].nr = (i<rows-1) ? Cells[i+1][j]: null;
    Cells[i][j].nd = (j<cols-1) ? Cells[i][j+1]: null;
    Cells[i][j].nul = (i>0 & j>0) ? Cells[i-1][j-1]: null;
    Cells[i][j].nur = (i<rows-1 & j>0) ? Cells[i+1][j-1]: null;
    Cells[i][j].ndl = (i<rows-1 & j<cols-1) ? Cells[i+1][j+1]: null;
    Cells[i][j].ndr = (i>0 & j<cols-1) ? Cells[i-1][j+1]: null;
  }
}
console.log(Cells);

var p3 = new Thing (g,50,10,[80,100,0,0],[0,0,100,80]);
var pl = new Main (g,100,100,[-10,10,10,-10],[-10,-10,10,10],270);
var block = [{"x":3},{"x":4},{"x":5}].forEach(function(d) {return new Thing(g,d.x*30,180,[0,30,30,0],[0,0,30,30]);})
//var block2 = g.append("polygon").attr("points",p3.string).style("fill","yellow").style("stroke","yellow");

var thg1 = new Thing(g,150,10,[80,100,0,0],[0,0,100,80]),
    thg2 = new Thing(g,250,10,[80,100,0,0],[0,0,100,80]);
    
var tick = new Event("tick"),
    incr=20,
    moveincr = 2,
    dispatch = d3.dispatch("tick"),
    tryslide = 1;

var hands = [{}]

var tmp = new ThingList();
tmp.add(thg1);
tmp.add(thg2);

dispatch.on("tick",function() {
  if(canMove) {
    if(tryslide) {
      if(keys[37])
        if(!pl.trymove(-moveincr,0,1)) {
          pl.trymove(-moveincr,-moveincr,1)
          pl.trymove(-moveincr,moveincr,1)
        }
      if(keys[38])
        if(!pl.trymove(0,-moveincr,1)) {
          pl.trymove(-moveincr,-moveincr,1)
          pl.trymove(moveincr,-moveincr,1)
        }
      if(keys[39])
        if(!pl.trymove(moveincr,0,1)) {
          pl.trymove(moveincr,-moveincr,1)
          pl.trymove(moveincr,moveincr,1)
        }
      if(keys[40])
        if(!pl.trymove(0,moveincr,1)) {
          pl.trymove(-moveincr,moveincr,1)
          pl.trymove(moveincr,moveincr,1)
        }
    }
    else {
      if(keys[37])
        pl.trymove(-moveincr,0,1)
      if(keys[38])
        pl.trymove(0,-moveincr,1)
      if(keys[39])
        pl.trymove(moveincr,0,1)
      if(keys[40])
        pl.trymove(0,moveincr,1)
    }
  }
  
  Things.forEach(function(obj) {obj.onStep();});
  setTimeout(dispatch.tick,incr);
});
dispatch.tick();


g.append("image");





var getClassOf = Function.prototype.call.bind(Object.prototype.toString);

// Initial printout
//console.log(p3.class)
//console.log(getClassOf(pl))
//console.log(Things);

// Next steps:
//  Add objects
//  Complex collisions (e.g. bouncing)
//  Create simple example
//  Simple way of creating many arrangements (.txt file, GUI, )
//  Goals (Count instances, check properties)
//  Events should probably just be all class function calls
//  Test scalability (Instanciate lots of objects) --> Too many slows it down quickly.
//  Slide diagonally -- Done.
//  Add sounds
//  Change direction with key presses

</script>
<h1>SVG embedded bitmaps in HTML</h1>

    <h2>Example 3: Local image</h2>
    <svg id="example3" height="200" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <image x="0" y="0" width="236" height="200" xlink:href="globe.jpg" />
    </svg>
</body>
</html>
